package database;

import java.sql.Connection;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class metadatamariadb {

    private final List<String> foreignKeys = new ArrayList<>();
   
    public metadatamariadb(Connection mariadb, Connection postgres) throws SQLException {
        DatabaseMetaData meta = mariadb.getMetaData();
        ResultSet tablas = meta.getTables(null, null, "%", new String[]{"TABLE"});
        while (tablas.next()) {
            String nombretabla = tablas.getString("TABLE_NAME");

            Statement st = mariadb.createStatement();
            ResultSet rsddl = st.executeQuery("SHOW CREATE TABLE " + nombretabla);

            String ddlmariadb = "";
            if (rsddl.next()) {
                ddlmariadb = rsddl.getString(2);
            }
            rsddl.close();

            String ddlpostgres = convertir(ddlmariadb, nombretabla);

            try (Statement stpg = postgres.createStatement()) {
                stpg.executeUpdate("DROP TABLE IF EXISTS " + nombretabla + " CASCADE");
                stpg.executeUpdate(ddlpostgres);
            } catch (Exception e) {
                System.out.println("Error creando tabla " + nombretabla + ": " + e.getMessage());
                continue;
            }

            migrarDatos(postgres, nombretabla, st);
            st.close();
        }
        tablas.close();

        for (String fk : foreignKeys) {
            try (Statement stpg = postgres.createStatement()) {
                stpg.executeUpdate(fk);
            } catch (Exception e) {
                System.out.println("Error en foreign key: " + e.getMessage());
            }
        }

        // Migrar vistas después de las tablas
        try {
            new VistaMigrator(mariadb, postgres);
        } catch (Exception e) {
            System.out.println("Error durante la migración de vistas: " + e.getMessage());
        }
    }

    private void migrarDatos(Connection postgres, String nombretabla, Statement st) {
        try {
            ResultSet rsdatos = st.executeQuery("SELECT * FROM " + nombretabla);
            ResultSetMetaData rsMeta = rsdatos.getMetaData();
            int columnas = rsMeta.getColumnCount();

            StringBuilder columnNames = new StringBuilder();
            for (int i = 1; i <= columnas; i++) {
                if (i > 1) columnNames.append(",");
                columnNames.append(rsMeta.getColumnName(i));
            }

            int filaCount = 0;
            while (rsdatos.next()) {
                filaCount++;
                StringBuilder insert = new StringBuilder("INSERT INTO " + nombretabla
                        + " (" + columnNames + ") VALUES(");

                for (int i = 1; i <= columnas; i++) {
                    Object val = rsdatos.getObject(i);
                    if (val == null) {
                        insert.append("NULL");
                    } else {
                        String columnType = rsMeta.getColumnTypeName(i).toUpperCase();
                        if (isNumericType(columnType) || isBooleanType(columnType)) {
                            insert.append(val.toString());
                        } else {
                            insert.append("'").append(val.toString().replace("'", "''")).append("'");
                        }
                    }
                    if (i < columnas) insert.append(",");
                }
                insert.append(")");

                try (Statement stPg = postgres.createStatement()) {
                    stPg.executeUpdate(insert.toString());
                } catch (Exception e) {
                    System.out.println("Error insertando fila " + filaCount + " en " + nombretabla + ": " + e.getMessage());
                }
            }
            System.out.println("Filas migradas en " + nombretabla + ": " + filaCount);
            rsdatos.close();
        } catch (Exception e) {
            System.out.println("Error migrando datos de " + nombretabla + ": " + e.getMessage());
        }
    }

    private boolean isNumericType(String type) {
        return type.contains("INT")
                || type.contains("DECIMAL")
                || type.contains("FLOAT")
                || type.contains("DOUBLE")
                || type.contains("NUMERIC")
                || type.contains("REAL");
    }

    private boolean isBooleanType(String type) {
        return type.contains("BOOLEAN")
                || type.contains("BOOL")
                || type.contains("TINYINT(1)");
    }

    public String convertir(String ddlMaria, String tableName) {
        if (ddlMaria == null || ddlMaria.isEmpty()) {
            return "";
        }

        String ddl = ddlMaria;
        ddl = ddl.replace("`", "");
        ddl = ddl.replace("AUTO_INCREMENT", "GENERATED BY DEFAULT AS IDENTITY");
        ddl = ddl.replaceAll("(?i)ENGINE\\s*=\\s*\\w+", "");
        ddl = ddl.replaceAll("(?i)DEFAULT CHARSET\\s*=\\s*\\w+", "");
        ddl = ddl.replaceAll("(?i)COLLATE\\s*=\\s*\\w+", "");
        ddl = ddl.replaceAll("(?i)COMMENT\\s*'[^']*'", "");
        ddl = ddl.replaceAll("(?i)UNSIGNED", "");
        ddl = ddl.replaceAll("(?i)TINYINT\\s*\\(1\\)", "BOOLEAN");
        ddl = ddl.replaceAll("(?i)TINYINT\\s*\\(\\d+\\)", "SMALLINT");
        ddl = ddl.replaceAll("(?i)SMALLINT\\s*\\(\\d+\\)", "SMALLINT");
        ddl = ddl.replaceAll("(?i)MEDIUMINT\\s*\\(\\d+\\)", "INTEGER");
        ddl = ddl.replaceAll("(?i)BIGINT\\s*\\(\\d+\\)", "BIGINT");
        ddl = ddl.replaceAll("(?i)(?<!SMALL|MEDIUM|BIG)INT\\s*\\(\\d+\\)", "INTEGER");
        ddl = ddl.replaceAll("(?i)DATETIME", "TIMESTAMP");
        ddl = ddl.replaceAll("(?i)VARCHAR\\s*\\(\\s*(\\d+)\\s*\\)", "VARCHAR($1)");
        ddl = ddl.replaceAll("(?i)TEXT\\s*\\([^)]+\\)", "TEXT");
        ddl = ddl.replaceAll("(?i)DEFAULT NULL", "");
        ddl = ddl.replaceAll("(?i),\\s*KEY\\s+\\w+\\s*\\([^)]*\\)", "");
        ddl = ddl.replaceAll("(?i)\\s+KEY\\s+\\w+\\s*\\([^)]*\\)", "");

        ddl = procesarForeignKeys(ddl, tableName);
        ddl = ddl.replaceAll("\\s+", " ").trim();
        ddl = ddl.replaceAll("AUTO_INCREMENT\\s*=\\s*\\d+", "");

        if (!ddl.endsWith(";")) {
            ddl += ";";
        }
        return ddl;
    }

    private String procesarForeignKeys(String ddl, String tableName) {
        StringBuilder mainDDL = new StringBuilder();
        String[] lines = ddl.split("\n");
        boolean inTableDefinition = false;

        for (String line : lines) {
            line = line.trim();

            if (line.startsWith("CREATE TABLE")) {
                inTableDefinition = true;
                mainDDL.append(line).append(" ");
                continue;
            }
            if (line.startsWith("(")) {
                mainDDL.append("(");
                continue;
            }
            if (line.startsWith(")")) {
                inTableDefinition = false;
                String current = mainDDL.toString().trim();
                if (current.endsWith(",")) {
                    mainDDL = new StringBuilder(current.substring(0, current.length() - 1));
                }
                mainDDL.append(")");
                continue;
            }

            if (inTableDefinition) {
                if (line.toUpperCase().contains("FOREIGN KEY") && line.toUpperCase().contains("REFERENCES")
                        || (line.toUpperCase().contains("CONSTRAINT") && line.toUpperCase().contains("FOREIGN KEY"))) {

                    String fkConstraint = extraerfks(line);
                    if (fkConstraint != null && !fkConstraint.isEmpty()) {
                        String fkStatement = "ALTER TABLE " + tableName + " ADD " + fkConstraint + ";";
                        foreignKeys.add(fkStatement);
                    }
                } else {
                    mainDDL.append(line).append(" ");
                }
            }
        }
        return mainDDL.toString();
    }

    private String extraerfks(String line) {
        try {
            int startIdx = line.toUpperCase().indexOf("CONSTRAINT");
            if (startIdx == -1) {
                startIdx = line.toUpperCase().indexOf("FOREIGN KEY");
            }

            if (startIdx >= 0) {
                String constraint = line.substring(startIdx).trim();
                if (constraint.endsWith(",")) {
                    constraint = constraint.substring(0, constraint.length() - 1);
                }

                int refEnd = constraint.toUpperCase().indexOf("REFERENCES");
                if (refEnd >= 0) {
                    int parenStart = constraint.indexOf("(", refEnd);
                    int parenEnd = constraint.indexOf(")", parenStart);
                    if (parenEnd >= 0) {
                        constraint = constraint.substring(0, parenEnd + 1).trim();
                    }
                }
                return constraint;
            }
        } catch (Exception e) {
            System.out.println("Error extrayendo constraint: " + line);
        }
        return null;
    }
}
